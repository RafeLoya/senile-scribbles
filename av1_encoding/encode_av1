#!/bin/bash
#
# AV1 Batch Encoding Script
# ab-av1 finds the optimal CRF, then av1an performs parallel encoding.

set -e  # exit on error

#-----------------------------------------------------------------------------#
# CONFIGURATION
#-----------------------------------------------------------------------------#

TARGET_VMAF=95              # Target VMAF score - skip if can't achieve this
FALLBACK_CRF=0              # Set to 0 to SKIP files where ab-av1 fails
                            # Set to a number (e.g., 28) 
                            # to encode anyway with that CRF
PRESET=6                    # SVT-AV1 preset (0-13, lower=slower/better)
INPUT_DIR="${1:-.}"         # Input directory (default: current dir)
OUTPUT_DIR="./encoded_av1"  # Output directory
EXTENSIONS="mp4 avi mov"    # File extensions to process (space-separated)
WORKERS=""                  # av1an workers (based on CPU cores)
                            #   Leave empty to auto-detect
AUDIO_CODEC="copy"          # copy to avoid re-encoding

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m'                # no color

#-----------------------------------------------------------------------------#
# FUNCTIONS
#-----------------------------------------------------------------------------#

log_info() { 
  echo -e "${GREEN}[INFO]${NC} $1"
}

log_success() {
  echo -e "${GREEN}[SUCCESS]${NC} $1"
}

log_warn() { 
  echo -e "${YELLOW}[WARN]${NC} $1"
}

log_error() {
  echo -e "${RED}[ERROR]${NC} $1"
}

###########################################################
# Check if FFmpeg, ab-av1, and av1an are installed
# Arguments:
# 	None
# Outputs:
# 	Writes error & success information to stdout
###########################################################
check_dependencies() {
  local missing=0

  for cmd in ffmpeg ab-av1 av1an; do
    if ! command -v "$cmd" &> /dev/null; then
      log_error "$cmd is not installed"
      missing=1
    fi
  done

  if [ $missing -eq 1 ]; then
    echo ""
    log_error "please install any missing dependencies:"
    echo "	FFmpeg: https://ffmpeg.org/download.html"
    echo "	ab-av1: cargo install ab-av1"
    echo "	av1an:  cargo install av1an"
    exit 1
  fi

  log_info "all dependencies found"
}

###########################################################
# Find optimal CRF for a video. Caches CRF in temporary
# hidden file in case of interrupts.
# Globals:
# 	TARGET_VMAF
# 	PRESET
# 	FALLBACK_CRF
# Arguments:
# 	Input file (video to encode).
# 	Cached CRF file (optional, autogenerated by script).
# Outputs:
# 	Writes error, warning, & success information to stdout.
# 	Writes CNF value to temporary hidden file for caching.
# Returns:
# 	0 if optimal CRF was found, 1 on error
###########################################################
find_opt_crf() {
  local in_file="$1"
  local crf_file="$2"

  log_info "analyzing: $(basename "$in_file")"
  log_info "  finding optimal CRF (target VMAF: $TARGET_VMAF)..."

  local crf_output
  if crf_output=$(ab-av1 crf-search \
    --input "$in_file" \
    --encoder svt-av1 \
    --min-vmaf "$TARGET_VMAF" \
    --preset "$PRESET" 2>&1); then

    # get CRF value from output
    local opt_crf
    opt_crf=$(echo "$crf_output" \
      | awk '/crf [0-9]+/ {for(i=1;i<=NF;i++) if($i=="crf") print $(i+1)}' \
      | tail -1)

    if [ -n "$opt_crf" ]; then
      echo "$opt_crf" > "$crf_file"
      log_info "  optimal CRF: $opt_crf"
      return 0
    else
      log_error "  could not extract CRF from ab-av1 output"
      return 1
    fi
  else
    log_error "ab-av1 could not find suitable CRF"
    log_warn "  Possible reasons:"
    log_warn "  - Can't achieve VMAF â‰¥$TARGET_VMAF while reducing file size"
    log_warn "  - AV1 encoding would make it larger"
    log_warn "  - Source quality too low"
    
    if [ "$FALLBACK_CRF" -gt 0 ]; then
      log_warn "  Using fallback CRF: $FALLBACK_CRF (may result in larger file)"
      echo "$FALLBACK_CRF" > "$crf_file"
      return 0
    else
      log_warn "  Skipping this file (set FALLBACK_CRF > 0 to encode anyway)"
      return 1
    fi
  fi
}

###########################################################
# Perform AV1 encoding. First attempts to do so with av1an,
# but will fall back to FFmpeg if an error occurs.
# Globals:
# 	PRESET
# 	AUDIO_CODEC
# 	WORKERS
# Arguments:
# 	Input file (video to encode).
# 	Output file.
# 	Optimal CRF value.
# Outputs:
# 	Writes error, warning, & success information to stdout
# 	Writes the output video to OUTPUT_DIR
# Returns:
# 	0 if video was encoded, 1 on error
###########################################################
encode_video() {
  local in_file="$1"
  local out_file="$2"
  local crf="$3"

  log_info "encoding: $(basename "$in_file") with CRF $crf"

  # build av1an command
  local av1an_cmd=(
    av1an
    -i "$in_file"
    -o "$out_file"
    -e svt-av1
    -v "--preset $PRESET --crf $crf"
    -a "-c:a $AUDIO_CODEC"
    -c ffmpeg
    --pix-format yuv420p
  )

  # add workers (if specified)
  if [ -n "$WORKERS" ]; then
    av1an_cmd+=(-w "$WORKERS")
  fi

  # start encoding (show output in real-time, 
  # but also capture for error detection)
  local encode_result
  local temp_log="/tmp/av1an_encode_$$.log"
  
  "${av1an_cmd[@]}" 2>&1 | tee "$temp_log"
  encode_result=${PIPESTATUS[0]}
  
  # check for frame mismatch, pixel format, or timestamp errors
  if [ $encode_result -ne 0 ] \
    && (grep -q "FRAME MISMATCH" "$temp_log" \
    || grep -q "does not support YUVJ420P" "$temp_log" \
    || grep -q "Timestamps are unset" "$temp_log" \
    || grep -q "unknown timestamp" "$temp_log"); then

    if grep -q "FRAME MISMATCH" "$temp_log"; then
      log_warn "frame mismatch detected - retrying with direct ffmpeg (no chunking)"
    elif grep -q "does not support YUVJ420P" "$temp_log"; then
      log_warn "YUVJ420P pixel format detected - retrying with direct ffmpeg (with conversion)"
    elif grep -q "Timestamps are unset\|unknown timestamp" "$temp_log"; then
      log_warn "timestamp corruption detected - retrying with direct ffmpeg (regenerating timestamps)"
    fi
    
    # remove output file from failed attempt
    rm -f "$out_file"
    
    # use ffmpeg directly (no av1an, no chunking)
    # -fflags +genpts regenerates timestamps for corrupted files
    # -pix_fmt yuv420p handles YUVJ420P conversion
    if ffmpeg -fflags +genpts \
      -i "$in_file" \
      -pix_fmt yuv420p \
      -c:v libsvtav1 \
      -preset "$PRESET" \
      -crf "$crf" \
      -c:a "$AUDIO_CODEC" \
      -y "$out_file"; then
      log_success "retry successful with direct ffmpeg"
      encode_result=0
    else
      log_error "retry failed even with direct ffmpeg"
      rm -f "$temp_log"
      return 1
    fi
  fi
  
  # cleanup temp log
  rm -f "$temp_log"
  
  # check final result
  if [ $encode_result -eq 0 ]; then
    log_info "successfully encoded: $(basename "$out_file")"

    # file size comparison
    local input_size=$(du -h "$in_file" | cut -f1)
    local output_size=$(du -h "$out_file" | cut -f1)
    local input_bytes=$(stat -f%z "$in_file" 2>/dev/null \
      || stat -c%s "$in_file" 2>/dev/null)
    local output_bytes=$(stat -f%z "$out_file" 2>/dev/null \
      || stat -c%s "$out_file" 2>/dev/null)
    local reduction=$(( 100 - (output_bytes * 100 / input_bytes) ))

    log_info "size: $input_size -> $output_size (${reduction}%)"
    return 0
  else
    log_error "encoding failed for: $(basename "$in_file")"
    return 1
  fi
}

#-----------------------------------------------------------------------------#
# MAIN
#-----------------------------------------------------------------------------#

main() {
  log_info "AV1 Batch Encoder"
  echo "input directory:  $INPUT_DIR"
  echo "output directory: $OUTPUT_DIR"
  echo "target VMAF:      $TARGET_VMAF"
  echo "SVT-AV1 preset:   $PRESET"

  check_dependencies

  mkdir -p "$OUTPUT_DIR"

  # find video files
  local files=()
  for ext in $EXTENSIONS; do
    while IFS= read -r -d '' file; do
      files+=("$file")
    done < <(find "$INPUT_DIR" -maxdepth 1 -type f -iname "*.$ext" -print0)
  done

  if [ ${#files[@]} -eq 0 ]; then
    log_warn "no video files found in $INPUT_DIR"
    exit 0
  fi

  log_info "found ${#files[@]} video file(s) to process"
  echo ""

  # process each file
  local success=0
  local failed=0
  for in_file in "${files[@]}"; do
    local filename=$(basename "$in_file")
    local name="${filename%.*}"
    local out_file="$OUTPUT_DIR/${name}.mkv"
    local crf_file="$OUTPUT_DIR/.${name}.crf"  # in case of interrupt / rerun

    echo ""
    log_info "processing: $filename"
    if [ -f "$out_file" ]; then
      log_warn "  output file already exists, skipping: $filename"
      continue
    fi

    # find optimal CRF (or use cached value)
    if [ -f "$crf_file" ]; then
      crf=$(cat "$crf_file")
      log_info "  using cached CRF: $crf"
    else
      if ! find_opt_crf "$in_file" "$crf_file"; then
        log_error "skipping $filename due to CRF detection failure"
        ((failed++))
        continue
      fi
      crf=$(cat "$crf_file")
    fi

    # encode video
    if encode_video "$in_file" "$out_file" "$crf"; then
      ((success++))
      rm -f "$crf_file"
    else
      ((failed++))
    fi
  done

  # summary
  echo ""
  log_info "encoding complete"
  echo "  successfully encoded: $success"
  if [ $failed -gt 0 ]; then
    echo "  failed: $failed"
  fi
  echo "  output directory: $OUTPUT_DIR"	
}

main "$@"